对于最大独立集：
dp[i][0] 表示不取i的最大值
dp[i][1]表示取i的最大值
表示不取父亲   dp[fa][0]+=max(dp[son][0],son[son][1]);可以去儿子节点或者不取；
表示取父亲      dp[fa][1]+=dp[son][0] 表示不能取儿子节点
这个题目就是判断唯一性比较复杂用mark[i][0] 标记i 的0 ，1状态是否能取到
对于mark[fa][1]=(mark[son][0]&all) 所有儿子节点的mark[son][0]必须唯一
对于mark[fa][0]  如果有一个儿子dp[son][0]=dp[son][1] 明显为0
如果取某个儿子的某种状态mark[son][?]必须全为1.
----------------------------------
对于最小点覆盖
fa为父亲节点
son为儿子节点
dp[i][1] 表示选了i的最小值
dp[i][0] 表示不选i的最小值
明显 dp[fa][0]+=dp[fa][1];
        dp[fa][1]+=min(dp[son][0],dp[son][1])
---------------------------------------------
树形dp 3连发 支配集和覆盖集有不同的定义，覆盖集一定是支配集，但是支配集不一定是覆盖集，覆盖集是每一条边必须有一个点被选择。
        但是支配集只要所有点 1包含在集合内 2 和他相连点在集合内。
比如  1->2->3->4->5->6 覆盖就最小为3 但是支配集为2（选取2 和5 就可以了）
3个状态 dp[i][0] 表示不选i时候最小值
               dp[i][1] 表示选了i时候最小值
               dp[i][2] 表示不选i但是i有至少一个儿子支配
dp[fa][1]=min(dp[son][0],dp[son][1],dp[son][2])+1;
dp[fa][0]=min(dp[son][1],dp[son][2]);
dp[fa][2]=min(dp[son][1],dp[son][2])+max(min(dp[son][1]-dp[son][2],0);(选其一个最优的儿子然后变成1)；
----------------------------------------------
其他树形dp多校训练中能体现出的是，记录最长 次长 次次长，在2次dfs 通过求解

